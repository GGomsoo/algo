# 동전 2
# 골드 V
'''
3 15
1
5
12
'''
N, K = map(int, input().split()) # 동전의 갯수 N, 목표 합 K

coins = []
for _ in range(N):
    C = int(input()) # 동전들을 입력 후 배열에 추가
    coins.append(C)
coins.sort() # 오름차순으로 정렬

dp = [10001] * (K+1) # K의 범위 - 1 <= K <= 10,000 --> dp를 K의 범위를 넘어선 10001로 채워넣는다.
dp[0] = 0 # 0원을 만들 때 사용되는 동전의 갯수는 0개다.

for coin in coins:
    for i in range(coin, K + 1):
        dp[i] = min(dp[i], dp[i-coin] + 1)
        # 1원만 사용한 경우 dp[1] = 1 ... dp[15] = 15 ( dp[i] = i )
        # 1원, 5원 사용한 경우 dp[5] 부터 사용되는 동전의 갯수가 달라진다.
        # dp[5] = 11111, 5 <-- 2가지 방법이 생기며, 각각 동전 5개, 1개를 사용한다
        # 문제에서, 동전을 최소로 사용하려고 한다.
        # 따라서 dp[5] = min(5, 1) = 1
        # dp[10] = 1111111111, 111115, 55 / 3가지 방법, min(10, 6, 2) = 2
        # 5원 만드는 방법에서 5원을 추가하면 10원이 되기에 동전을 2개만 사용하면 된다.
        # 마찬가지로 dp[12] = 111111111111, 11111115, 1155, 12 = min(12, 8, 4, 1) = 1 ( 12원 동전 1개만 사용하면 된다. 0원에서 12원 만드는 방법 )
        # 따라서 점화시 dp[i] = min(dp[i], dp[i-coin] + 1)

if dp[K] == 10001:
    print(-1)
else:
    print(dp[K])